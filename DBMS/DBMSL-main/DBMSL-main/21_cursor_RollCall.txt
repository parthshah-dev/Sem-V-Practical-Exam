Question:
Write a PL/SQL block to implement all types of cursor (Implicit, Explicit, Cursor FOR Loop, Parameterized Cursor).
Also write a PL/SQL block of code using parameterized Cursor, that will merge the data available in the newly created table N_RollCall with the data available in the table O_RollCall.
If the data in the first table already exists in the second table, then that data should be skipped.

================== Answer ===================
Step 1: Start SQL*Plus
sqlplus username/password@database

Step 2: Create Tables
CREATE TABLE N_RollCall (
    RollNo NUMBER PRIMARY KEY,
    Name VARCHAR2(30),
    Status VARCHAR2(10)
);

CREATE TABLE O_RollCall (
    RollNo NUMBER PRIMARY KEY,
    Name VARCHAR2(30),
    Status VARCHAR2(10)
);

Step 3: Insert Sample Data
INSERT ALL
    INTO N_RollCall VALUES (1, 'Rahul', 'Present')
    INTO N_RollCall VALUES (2, 'Amit',  'Absent')
    INTO N_RollCall VALUES (3, 'Suresh','Present')
    INTO N_RollCall VALUES (4, 'Neha',  'Present')
SELECT * FROM dual;

INSERT ALL
    INTO O_RollCall VALUES (1, 'Rahul', 'Present')
    INTO O_RollCall VALUES (2, 'Amit',  'Absent')
SELECT * FROM dual;

Step 4:PL/SQL Block – Cursors and Merge
---------------------------------------

SET SERVEROUTPUT ON

-- Display menu
BEGIN
   DBMS_OUTPUT.PUT_LINE('==============================');
   DBMS_OUTPUT.PUT_LINE('         CURSOR MENU          ');
   DBMS_OUTPUT.PUT_LINE('==============================');
   DBMS_OUTPUT.PUT_LINE('1. Implicit Cursor (1 row at a time)');
   DBMS_OUTPUT.PUT_LINE('2. Explicit Cursor');
   DBMS_OUTPUT.PUT_LINE('3. Cursor FOR Loop');
   DBMS_OUTPUT.PUT_LINE('4. Parameterized Cursor (Simple Display)');
   DBMS_OUTPUT.PUT_LINE('5. Parameterized Cursor (Merge into O_RollCall)');
   DBMS_OUTPUT.PUT_LINE('==============================');
END;
/

-- Accept user choice
ACCEPT choice NUMBER PROMPT 'Enter your choice (1-5): '

-- PL/SQL block: reset O_RollCall, insert base rows, perform chosen operation
DECLARE
   v_choice NUMBER := &choice;

   CURSOR c_explicit IS
      SELECT RollNo, Name, Status FROM N_RollCall;

   CURSOR c_param(p_roll NUMBER) IS
      SELECT RollNo, Name, Status FROM N_RollCall WHERE RollNo = p_roll;

   v_rec N_RollCall%ROWTYPE;
BEGIN
   -- Reset O_RollCall
   EXECUTE IMMEDIATE 'TRUNCATE TABLE O_RollCall';

   -- Insert base 3 rows
   INSERT INTO O_RollCall VALUES (1, 'Rahul',  'Present');
   INSERT INTO O_RollCall VALUES (2, 'Amit',   'Absent');
   INSERT INTO O_RollCall VALUES (3, 'Suresh', 'Present');
   COMMIT;

   -- Merge logic based on choice
   IF v_choice = 1 THEN
      -- Implicit cursor row-by-row: insert only 1 new row
      BEGIN
         DECLARE
            v_r N_RollCall%ROWTYPE;
         BEGIN
            SELECT RollNo, Name, Status
            INTO v_r.RollNo, v_r.Name, v_r.Status
            FROM N_RollCall n
            WHERE NOT EXISTS (SELECT 1 FROM O_RollCall o WHERE o.RollNo = n.RollNo)
              AND ROWNUM = 1;

            INSERT INTO O_RollCall VALUES (v_r.RollNo, v_r.Name, v_r.Status);
         EXCEPTION
            WHEN NO_DATA_FOUND THEN NULL;
         END;
      END;

   ELSIF v_choice = 2 THEN
      -- Explicit cursor: loop through all rows
      OPEN c_explicit;
      LOOP
         FETCH c_explicit INTO v_rec.RollNo, v_rec.Name, v_rec.Status;
         EXIT WHEN c_explicit%NOTFOUND;
         BEGIN
            INSERT INTO O_RollCall
            SELECT v_rec.RollNo, v_rec.Name, v_rec.Status
            FROM dual
            WHERE NOT EXISTS (SELECT 1 FROM O_RollCall o WHERE o.RollNo = v_rec.RollNo);
         EXCEPTION
            WHEN DUP_VAL_ON_INDEX THEN NULL;
         END;
      END LOOP;
      CLOSE c_explicit;

   ELSIF v_choice = 3 THEN
      -- Cursor FOR loop
      FOR rec IN c_explicit LOOP
         BEGIN
            INSERT INTO O_RollCall
            SELECT rec.RollNo, rec.Name, rec.Status
            FROM dual
            WHERE NOT EXISTS (SELECT 1 FROM O_RollCall o WHERE o.RollNo = rec.RollNo);
         EXCEPTION
            WHEN DUP_VAL_ON_INDEX THEN NULL;
         END;
      END LOOP;

   ELSIF v_choice = 4 THEN
      -- Parameterized cursor – simple display
      FOR rec IN (SELECT RollNo FROM N_RollCall) LOOP
         OPEN c_param(rec.RollNo);
         FETCH c_param INTO v_rec;
         IF v_rec.RollNo IS NOT NULL THEN
            DBMS_OUTPUT.PUT_LINE('RollNo: ' || v_rec.RollNo || ', Name: ' || v_rec.Name || ', Status: ' || v_rec.Status);
         END IF;
         CLOSE c_param;
      END LOOP;

   ELSIF v_choice = 5 THEN
      -- Parameterized cursor – merge into O_RollCall
      FOR rec IN (SELECT RollNo FROM N_RollCall) LOOP
         OPEN c_param(rec.RollNo);
         FETCH c_param INTO v_rec;
         IF v_rec.RollNo IS NOT NULL THEN
            BEGIN
               INSERT INTO O_RollCall
               SELECT v_rec.RollNo, v_rec.Name, v_rec.Status
               FROM dual
               WHERE NOT EXISTS (SELECT 1 FROM O_RollCall o WHERE o.RollNo = v_rec.RollNo);
            EXCEPTION
               WHEN DUP_VAL_ON_INDEX THEN NULL;
            END;
         END IF;
         CLOSE c_param;
      END LOOP;
   END IF;

   COMMIT;
   DBMS_OUTPUT.PUT_LINE('Operation Completed.');
END;
/

-- Verify O_RollCall table
SELECT RollNo, Name, Status FROM O_RollCall ORDER BY RollNo;

-------------------------------------------------------------------

Step 6: Verify the Merge / Output
After executing the PL/SQL block, run:
SELECT * FROM O_RollCall ORDER BY RollNo;
SELECT * FROM N_RollCall ORDER BY RollNo;
This shows the final state of O_RollCall after the merge.
Option 5 ensures only non-duplicate rows from N_RollCall are inserted into O_RollCall.

Step 7: Commit Changes
COMMIT;

Step 8: Exit SQL*Plus
EXIT;


=================Theory========================
Theory
What is PL/SQL:
PL/SQL (Procedural Language/SQL) is Oracle’s extension of SQL that allows procedural programming with variables, loops, conditions, and exception handling for database operations.

Practical Related Concepts:
Implicit Cursor:
Automatically used for single-row queries.
SELECT Name INTO v_name FROM N_RollCall WHERE RollNo = 1;

Explicit Cursor:
Manually controlled for multi-row fetch.
CURSOR c_name IS SELECT * FROM N_RollCall;
OPEN c_name; FETCH c_name INTO v_rec; CLOSE c_name;

Cursor FOR Loop:
Auto-handles open, fetch, close for each record.
FOR rec IN (SELECT * FROM N_RollCall) LOOP
    DBMS_OUTPUT.PUT_LINE(rec.RollNo || ' ' || rec.Name);
END LOOP;

Parameterized Cursor:
Accepts input to fetch specific data.
CURSOR c_param(p_roll NUMBER) IS SELECT * FROM N_RollCall WHERE RollNo = p_roll;

Merge Using Parameterized Cursor:
Fetch records from N_RollCall
Insert into O_RollCall if not already present.
Handle duplicates with DUP_VAL_ON_INDEX.

Exception Handling:
DUP_VAL_ON_INDEX handles duplicate primary key errors.
NO_DATA_FOUND handles queries returning no rows.

DBMS_OUTPUT.PUT_LINE:
Used to display results in SQL*Plus.

This program demonstrates all cursor types, parameterized execution, merge logic, exception handling, and row-by-row or loop-based insertion.
